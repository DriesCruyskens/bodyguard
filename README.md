# Bodyguard 3 ðŸ’ª

[![Module Version](https://img.shields.io/hexpm/v/bodyguard.svg)](https://hex.pm/packages/bodyguard)
[![Hex Docs](https://img.shields.io/badge/hex-docs-lightgreen.svg)](https://hexdocs.pm/bodyguard/)
[![Total Download](https://img.shields.io/hexpm/dt/bodyguard.svg)](https://hex.pm/packages/bodyguard)
[![License](https://img.shields.io/hexpm/l/bodyguard.svg)](https://github.com/schrockwell/bodyguard/blob/master/LICENSE)
[![Last Updated](https://img.shields.io/github/last-commit/schrockwell/bodyguard.svg)](https://github.com/schrockwell/bodyguard/commits/master)
[![tests](https://github.com/schrockwell/bodyguard/actions/workflows/tests-v3.yml/badge.svg)](https://github.com/schrockwell/bodyguard/actions)

Bodyguard is a simple, flexible authorization solution. 

Its tenets are:

* **A minimal core** - Authorization is based around a single `permit?/3` callback.
* **Opt-in functionality** - Modules can `use Bodyguard.Policy` for a little extra "oomph".
* **Generator-based integrations** - Generators are provided a starting points for common use cases.

Version 3 has an all-new API, so refer to [the `2.x` branch](https://github.com/schrockwell/bodyguard/tree/2.x) for the earlier readme.


## Basic Example

Here is an example of a policy for a blog application, which specifies how users can make access and modify blog posts.

```elixir
# lib/my_app/blog/post_policy.ex
defmodule MyApp.Blog.PostPolicy do
  # Blacklist by default
  use Bodyguard.Policy, fallback_to: false

  alias MyApp.Accounts.User
  alias MyApp.Blog.Post

  # Admins can do anything
  def permit?(%User{role: :admin}, _, _),
    do: true

  # Users can create posts
  def permit?(%User{}, action, _) when action in [:new, :create],
    do: true

  # Users can do anything to their own posts
  def permit?(%User{id: user_id}, _, %{post: %Post{author_id: user_id}}), 
    do: true

  # Guest users can only view published posts
  def permit?(nil, :show, %{post: post}),
    do: post.published?
end
```

And an example Phoenix controller, using the Plug generated by `mix bodyguard.gen.plug`. This example assumes that `:current_user` is already on the Conn assigns.

```elixir
# lib/my_app_web/controllers/post_controller.ex
defmodule MyAppWeb.PostController do
  use MyAppWeb, :controller

  plug :assign_post when action in [:edit, :update, :delete]
  plug MyAppWeb.Plugs.Authorize, policy: MyApp.Blog.PostPolicy

  # ...controller actions...

  defp assign_post(%{path_params: %{"id" => id}} = conn, _) do
    assign(conn, :post, MyApp.Blog.get_post!(id))
  end
end
```

## Generators

The following generators are provided as jumping-off points for integrating policies into your application. See [the docs](https://hexdocs.pm/bodyguard/) or `mix help` for complete documentation.

* `mix bodyguard.gen.policy` - creates a policy module
* `mix bodyguard.gen.plug` - creates a generic authorization plug for Phoenix apps

## Where Should I Perform Checks?

Bodyguard doesn't make any assumptions about where authorization checks are performed. You can do it before calling into the context, or within the context itself. There is a good discussion of the tradeoffs [here](https://dockyard.com/blog/2017/08/01/authorization-for-phoenix-contexts).

## Testing

Testing is pretty straightforward â€“ use the `Bodyguard` top-level API.

```elixir
assert :ok == Bodyguard.permit(MyApp.Blog, :successful_action, user)
assert {:error, :unauthorized} == Bodyguard.permit(MyApp.Blog, :failing_action, user)

assert Bodyguard.permit?(MyApp.Blog, :successful_action, user)
refute Bodyguard.permit?(MyApp.Blog, :failing_action, user)

error = assert_raise Bodyguard.NotAuthorizedError, fun ->
  Bodyguard.permit(MyApp.Blog, :failing_action, user)
end
assert %{status: 403, message: "not authorized"} = error
```

## Installation

1. Add `:bodyguard` to your list of dependencies:

    ```elixir
    # mix.exs
    def deps do
      [
        {:bodyguard, "~> 3.0"}
      ]
    end
    ```

2. Generate your first policy with `mix bodyguard.gen.policy`.

## Alternatives

Not what you're looking for?

- [Roll your own](https://dockyard.com/blog/2017/08/01/authorization-for-phoenix-contexts)
- [PolicyWonk](https://github.com/boydm/policy_wonk)
- [Canada](https://github.com/jarednorman/canada)
- [Canary](https://github.com/cpjk/canary)

## Community

Join our communities!

- [Slack](https://elixir-lang.slack.com/messages/CHMTNPSEN/)

## License

MIT License, Copyright (c) 2022 Rockwell Schrock
